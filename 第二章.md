# <center>第二章 
------

##Objective-C 与面向对象




Objective-C 是一种面向对象的语言。本章将教你理解面向对象的含义，Objective-C 如何实现面向对象，以及你定义的对象在Objective-C程序中存在的形式。

毫无疑问，面向对象编程是新鲜事物，19世纪80年代开始流行。
它保留了大多数共通的编程规范，而且特别适用开发公开某类接口给用户的应用，因为人们习惯就他们所见所接触的对象来思考。

Objective-C 使用一种非常独特的方式去实现所谓的面向对象。这带来了一系列的好处，让开发者以较少的代价去理解关于面向对象如何工作的细节以及CoCoa 对你代码的期待。

###面向对象编程

在任何平台开发任何应用，你都会将代码组成不同的部分，每一个部分负责程序不同的功能区。这表示你程序每一个任务的逻辑应该避免相互耦合。

比如，通过网络和数据库交互的代码就不应该和展示结果给用户的代码混在一起。相反，你应该把代码分成数据库处理层和数据展示层。如果这两层需要交互，那么你就应该清晰地定义接口。

这样以为着你代码是易写，易维护和易调试的。这么让代码也容易模块化，因为在不影响程序其他部分的情况下，添加代码（或替换）就变得很直接。

除了根据目的分离逻辑外，程序的数据也应该分离。比如，用于展示信息的相关数据（例如字体，颜色，屏幕的位置）不能被负责和数据库交互的代码所修改。另外，你的逻辑应该能够在假设所要处理的数据不会被程序其他部分修改的前提下正常工作。

面向对象语言通过引进对象的概念推崇和强制这种分离。

###对象

对象是由数据块和定义在数据块的操作组成的。只有对象内部的代码才能修改数据，但对象之间可以通过共享数据进行通信。

这种隐藏数据的方式称为封装，并且可确保改变一个对象的数据仅能通过对象的函数进行。

同一个对象的多个副本能够同一时间存在。每个副本称为对象的一个实例。创建实例的模版则称为类。当你编写面向对象的代码时，你要编写类，然后通过类创建一个或多个实例。

一个对象里面的数据称为实例变量。而其函数则称为方法。

在大多数面向对象的语言里，一个方法既可以是实例方法，也可以是类方法。Objective-C 里所谓的类方法，通常用于创建类的实例。比如，类NSData中一个叫dataWithContentsOfFile：的类方法，可以加载文件并返回NSData对象。

###继承

面向对象语言允许通过另一个类定义子类。子类和父类相同，但可以添加额外的方法和实例变量。

子类创建了一个版本更加具体的类。例如，你定义了一个Server 类，用于处理诸如接收网络连接的任务，然后分别创建了FTPServer 和 HttpServer 子类，处理更具体的连接任务。

在Objective-C 中，一个类只有一个父类（不同于C＋＋， 支持多个父类）。

子类可以覆盖父类的方法。它的意思是，可以编写一个替换父类一个或多个方法的子类--确切地说，使用Cocoa编程的大部分主要工作都涉及到替换某些方法。

### 接口和实现

每个对象都有访问域：私有域，公开域。
一个类的公开域就是所谓的接口。它列出了其他类所有能够访问方法（在Objective-C中，没有公开的实例变量一说，然而可以用属性代替，作用一样，但可以更好地控制其他对象访问本对象的数据）

一个类私有域就是所谓的实现。它包含为类编写的代码，也包含了任何属于该类的私有变量。

当你使用一个对象，仅仅是使用对象的接口。这意味着每个对象在其他对象能够对本对象数据做什么和本对象函数能够做什么之间是严格区分的。

在Objective-C，一个类的接口的声明和实现是分开的，并且放在不同的文件。包含了类接口的文件叫头文件（历史原因），而包含了类实现的文件则是实现文件。头文件以.h为扩展名；实现文件则以.m。

Objective-C 的类接口类似如下：

	@interface MyObject : NSObject {
		[instance variables]
	}
		[method declarations]
	
	@end
	
`@interface`一行定义了类的名字，同时指明了其父类。在花括号里面，可以声明实例变量－这是可选的，同样你可以在实现文件里面声明这些变量；参考第30页“类扩展”。

对应的实现文件类似如下：

	@implementation MyObject
		[method implementations]
	@end
	
### 方法
方法即是属于类里面的函数。和其他函数一样，可以带参数和有返回值。

之前说过，方法分为实例方法和类方法。实例方法属于一个类的实例，只能访问实例变量。类方法则不能访问实例变量，因为其不属于实例对象。

Objective-C 声明方法如下:

	- (void) launchPlane;
以上声明了一个不带参数，没有返回值名为launchPlane的方法。 方法名前面的 `－` 表示它是个实例方法；类方法则需要 `+`。

Objective－C 比较有趣的由独特的一个地方就是，它的方法参数混合着参数名。举例会比较容易解释。

比如，下面是带一个参数的方法：

	- (void) launchPlane: (NSString*) planeName;
	
方法里面的参数planeName 是一个指向 NSString 对象的指针。

对比下面带两个参数的方法：

	－(void) launchPlane: (NSString*) planeName fuelCapacity: (int) litresOfFuel;
	
这个方法带有一个NSString 的指针planeName和一个int 的 litresOfFuel 参数。此时参数名是并入方法名的。

调用一个对象的方法的语法同样和其他语言很不同。假设一个planeLauncher 对象调用方法：

	[planeLauncher launchPlane];
	
可以看到，调用方法的对象在方括号的作左边，而方法名则在右边。对多个参数的方法的调用，语法差不多，并入的参数几乎和声明是一样：

	[planeLauncher launchPlane: @"Boeing 747-300" fuelCapacity: 183380];

Objective-C 设计成让代码从左到右读起来由意义。例如，读一下上面例子（忽略英语语法）。你几乎可以想像成一条命令。

在`interface` 处声明一个类的方法。举例如下：

	@interface SomeObject : NSObject
	- (void) launchPlane: (NSSTring *) planeName;
	- (int) numberOfPlanesInTheAir;

### 消息
Objective-C 是消息传递语言，很想Ruby.这个特性使它区别于像C＋＋这样使用早绑定方法调用的语言。

它意味着一个对象接收一个方法调用时，会在运行时查询去决定运行何种代码。相反，C++ 和其他语言在编译期处理。

当对象接收到方法调用时，Objective-C 会在运行时查询对象所实现的方法列表。如果找到该方法匹配的消息，就运行代码。否则，就开始递归查找父类的方法列表，直到找到或不能查找为止。这时，运行时抛出异常，程序中指运行。可以不这样做－－你可以捕获异常并处理。XCode 就是这么做的：如果由异常，Xcode 就展示错误信息，并允许用户忽略或终止程序。

这意味着对象可以用它所接收的消息去做一些有意思的事。例如，（to do）。还可以写自己的逻辑处理没有方法匹配的消息的情况（通常用在数据库的处理代码）

因为方法声明和代码是分离的，Objective-C 比其它编译语言更具动态性。Cocoa 的威力就是来自这种动态性。在日常工作中，方法和消息的区别并不是很重要。不过，越是明白Objective-C 工作原理和Cocoa 的优势就越好。

### 属性

面向对象编程中，一个对象直接访问另一个对象的数据是糟糕的实践。它破坏了封装，使得一个对象的代码依赖一个对象的存储数据。

为了访问和改变另一个对象的变量，可以使用`setter`和`getter` 实例方法。后者返回变量当前值，前者则改变变量的值。

这两个方法命名需要遵守一些约定。例如，有个实例变量 planeName, setter 方法命名为 setPlaneName: 而getter 方法则命名为 planeName.

由于实例变量不允许被其他对象直接访问，如果想被其他对象访问，每个实例变量都要包括getter 和 setter 方法。这样就需要手动写大量getter 和 setter 方法。自从2007 年发布了Objective-C 2.0 后，它包含了一些新特性，移除了这种手写方法，同时使得实例变量易于暴露给其他类。

当声明一个可以由其他类的实例访问的变量时，可以这么做：

	@interface SomeClass : NSObject
	@property (strong, nonatomic) NSObject* myProperty;
	@end
	
属性声明在 `interface` 之间，关键字为 `@property`，其后的括号里面则是该属性的特性列表，接着就是属性类型和名字。

属性的特性描述属性对其他对象（或编译器）行为，如下：

	strong
	表示属性强引用。参考 “对象表”。一个对象使用 `strong` 和 `weak` 的属性，可以控制被引用的属性是否保留在内存中。
	
	weak
	表示属性弱引用。当引用该属性的对象释放时，属性会自动置为nil。
	
	assign
	这个属性的setter 方法仅进行简单的赋值，没内存管理。

	copy
	这个属性的setter 方法会复制所赋对象，创建原对象的副本。
	
	readwrite
	这个属性会产生setter 和 getter 方法（默认设置，当覆盖父类的属性时需要显式设置）

	readonly
	属性不会产生setter 方法，使属性对其他类来说只读（所属类依然可以修改）。
	
	nonatomic
	改变变量值时，属性的setter 和 getter 方法不会加锁，使之线程安全。
	
当你声明属性时，编译器自动产生实例变量存储属性值，还有自动产生getter 和 setter 方法。实例名默认和属性命一致。如果想要实例变量有不同的调用，可以在属性前手动添加`@synthesize`指令：

	@implementation MyClass
	@synthesize myProperty = _myCustomVariableName;
	// the rest of class code goes here
	@end
	
可以用 `@dynamic` 指令告诉编译器不要合成属性和方法。
但你需要自己实现 getter 和 setter 方法：

	@implementation MyClass
	@dymatic myProperty;
	
	- (int) myProperty{
		// this is the getter method for this property
		
		return 123;
	}

	- (void) setMyProperty: (int) newValue {
		// this is the setter method for this property
	}
	
	@end
	
### 协议

	
