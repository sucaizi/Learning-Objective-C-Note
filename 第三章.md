# <center>第三章 框架

框架是构成支持所有Objective-C 开发的库的基础。其中包括提供了对诸如字符串，数组，字典，其他通用对象及其适配的方法的支持。

框架比Cocoa库处于更低的抽象层次。Cocoa库和UIKit套件关心的应用程序，视图以及用户输入，而框架则关注组织数据的底层任务。在本章中，你将学习框架提供的一些重点类，以及了解Cocoa 和 Cocoa Touch 所依赖的设计模式。

### 可变和不可变对象

框架里面几乎所有存储数据的对象都分成两种：可变和不可变。可变对象可在对象创建后被修改，不可变对象则不能。

例如，NSArray类，它把对象存储成一个列表，但你不能往里添加，删除，替换对象。如果你想改变它的内容，则需要使用NSMutableArray类。

为什么有可变和不可变对象呢？两个理由：

1. 如果一个对象是不可变的，说明它所在内存是不能被修改的，因此更有效率。
2. 如果你传递了一个不可变对象给另一个对象，可以明保证这个对象永远不能被其他对象修改。

你可以为一个已有对象创建其不可变的版本。（反之亦然－你可以创建其可变的版本）例如，通过NSArray 创建 NSutableArray（后续章节会更详细介绍）：

	// here, 'someArray' is an NSArray
	NSMutableArray* mutableArray = [NSMutableArray arrayWithArray: someArray];
	
可变和不可变对象都有各自的用处。大多数情况，编写Mac 和 iOS 应用时用到的是不可变对象。Cocoa常把这些对象作为参数传递，保证类似传递NSArray对象给另一个方法时，不会修改其内容。如果你是java开发者，可能对这种从语言级别区分可变和不可变对象会感到一丝陌生，因为java里习惯使用可变对象。不过随着使用时间变长，你会发现这种区分很有用。

### 字符串

简单来说，字符串就是一块文本信息。Objective-C应用处理到文本的地方，基本都会用到NSString，以后你会慢慢熟悉NSString的。

由于字符串可存储文本，所以常用于存储我们所写的自然语言（一般用unicode编码）。

#### 字符串的创建

字符串用NSString 类表示，使Objective-C 对待字符串像其他对象一样。你可以这样创建一个空字符串：

	NSString* aString = [[NSString alloc] init];
	
不推荐这样做，因为NSString 类是不可变的，所以上面创建的空字符串不能被修改。其他的创建方法，比如通过加载文件内容创建，或在代码提供内容来创建，会更有用。

Objective-C 使用字符串是非常普遍的，故此提供了一种快速创建方法：

	NSString* aString = @"Hello, World!";
	
注意双引号前面的‘@’ 符号，它告诉编译器创建的是NSString对象而不是C标准的字符串（不属于Objective-C 对象）。因为NSString 是符合Objective-C 标准的对象，所以它可以几首消息，并和应用中其他对象通信。比如，你可以获取新字符串又多少个字符：

	NSInteger sizeofString = [@"Hello, world!" length];
	
用这种语法定义的字符串对象称为文本型字符串。

#### 字符串的使用

字符串对象提供良好的扩展性和内置大量的方法。大多数情况，字符串有两种用途：处理自然语言和文件路径。这意味NSString 提供大量的方法用于处理这些数据。

NSString 创建的三种方法：

1. 使用文本，如：@“this example”。
2. 由其它数据加载，如文件
3. 由已存在的字符串。

由文本创建字符串的语法：

	NSString* constantString = @"Text of the string";
	
这种创建的字符串对象，可以直接添加到数组和字典里，后续详细介绍。
	
##### 大小写和路径

由于字符要处理自然语言，所以提供一些使用的方法用做转换处理。
如大小写转换：

	NSString* originalString = @"This is An Example";
	
	// "THIS IS AN EXAMPLE"
	NSString* uppercase = [originalString uppercaseString]
	
	// "this is an example"
	NSString* lowerCaseString = [originalString lowercaseString];
	
	// "This Is An Example"
	NSString* capitalizedString = [originalString capitalizedString];
	
注意，调用上述方法不会改变原字符串，因为它是不可变的；相反，凡涉及处理字符串内容的方法，都会返回一个新字符串对象。

##### 查找子符

在使用字符串时，有时需要提取子串，例如从“hello world” 中的hello。

为了提取子串，可以指定从原字符串的某位置开始直到结尾或从开头到指定位置结束进行查找。也可以在指定的范围内的字符进行查找。

想得到一个字符串前5个字符，可以：

	NSString* startSubstring = [originalString substringToIndex: 5]; // "This "

想得到一个字符串从第5个位置往后的所有字符，可以：

	NSString* endSubstring = [originalString substringFromIndex: 5]; // "is An EXAMPLE"
	
想得到某范围内的字符，首先要创建一个 NSRange 的结构体，它定义了范围值。比如，指定从第3个字符开始长度为5的字串，可以：

	NSRange theRange = NSMakeRange(2, 5);

NSRange 有两个变量：位置和长度。位置是从0开始，所以上面的定义需要从2开始。

一旦定义好了NSRange，就可以这样获取子串：

	NSRange theRange = NSMakeRange(2, 5);
	NSString* subString = [originalString substringWithRange: theRange]; //"is is"

#### 比较字符串

字符串比较是常用的操作，不过，不能像下面的代码这样做：
	
	// firstString contains "one" and secondString is another object,  
	// also containing "one"
	if (firstString == secondString){
	  // do something
	}

因为 == 操作符只是比较两个变量的指针，实际上检查两个变量在内存位置是否一样，通常结果是否定的。

正确的做法是使用 isEqualToString: 方法：

	if ([firstString isEqualToString: secondString]){
	  // do something
	}
	
当两个字符串内容完全相同，方法返回True，否则False。这个方法大小写敏感。

#### 搜索字符串

除了检查两个字符串是否一样，你还可以获取字符串所包含更多信息。在Cocoa，你可以查找字符串是否包含特定的子串，或者对比两个字符串看看他们如何排序。

查找子串，还是使用rangeOfString 系列方法。调用这些方法，如果子串找到，会返回NSRange，否则，返回的NSRange 中的位置变量是一个NSNotFound常量。例如：

	NSString* sourceString = @"Four score and seven ago";
	NSRange range = [sourceString rangeOfString: @"seven"];
	if(range.location == NSNotFound){
	  // the string was not found
	} else {
	  // the string was found; 'range' variable contains info on where it is
	}
	
搜索子串还可以限制范围，或提供可选参数。比如：可以在搜索子串时忽略大小写：

	NSString* sourceString = @"Four score and seven years ago";
	NSRange range = [sourceString rangeOfString: "SEVEN" options: NSCaseInsensitiveSearch];
	
### 数组

简而言之，数组是对象的列表。它按序存储对象，允许你一次引用一个或全部对象。

数组是Cocoa 里重要的容器类之一，因为它可以在内存允许的情况下存储任意多的对象。任何时候一个方法需要使用一个或多个对象，NSArray几乎都可以用于存储它们。

和NSString一样，NSArray是不可变的－－一旦被创建，就不能新加或移除其中的对象。所以，创建NSArray时，需要提供要存储的对象。有多种方法可以实现，比如：使用其他数组的元素来创建。

只要是Objective－C 对象，都可以存储在数组，这些对象不需要是相同的类型－－可以将NSString对象和NSView对象存储在同一数组。数组也可以存储其他数组，因为NSArray 本身也是对象。

类似NSString的对象，创建NSArray对象也是特别的：

	NSArray* myArray = @[@"one", @"two", @"three"];
	
这样就创建了一个新的，不可变的，且包含NSString对象的数组。

要从数组中获取某对象，语法是：

	NSString* oneString = myArray[0];
	NSString* twoString = myArray[1];
	
数组需要注意的地方：

*  数组从0开始计数，对应第一个对象，其他依此类推。
*  如果使用无效的下标，会导致异常或崩溃。比如，一个有3个对象的数组，你想取下标为3的对象，就会导致异常（下标3对应第4个对象）。
*  iOS5 以下的版本不支持直接访问数组元素的，你需要使用较为啰嗦的方法objectAtIndex: ，如下：
	
		NSString* oneString = [myArray objectAtIndex: 0];
	
	这个方法兼容iOS 7， 所以如果你的代码要兼容其他版本，就可以用这个方法。
	
同样地，你也可以通过count 属性获取数组元素的个数。

	int count = myArray.count;
	// count now equals 3
	
由于NSArray 是对象，所以和其他对象一样可以接收消息。比如，要获知某对象在数组的下标可发送indexOfObject: 方法，如果不存在，方法就返回一个特殊值 NSNotFound：

	NSArray* myArray = @[@"one", @"two", @"three"];
	int index = [myArray indexOfObject: @"two"]; // should be equal to 1
	
	if (index == NSNotFound){
		NSLog(@"Couldn't find the object!");
	}
	
若要从其他数组创建一个新数组，可以使用subArrayWithRange: 方法，它需要一个NSRange 参数。新数组里面的对象不会复制过来--即两个数组共同引用这些对象，所以其中一个数组修改了某个对象的属性，必然影响另一个。

	如果你想把对象拷贝过来，你可以发送copy 消息，它会返回对象一个副本。但不是所有对象都支持拷贝，需要对象实现NSCopying 协议。
	
下面是一个例子：
	
	NSArray* myArray = @[@"one", @"two", @"three"];
	NSRange subArrayRange = NSMakeRange(1,2);
	NSArray* subArray = [myArray subArrayWithRange: subArrayRange];
	// subArray now contains "two", "three"

### 快速列举

对于一个容器，有时需要访问它里面的每一个对象，Objective-C 有个特性叫快速列举，允许你快速高效遍历容器的对象。

遍历数组对象，你需要这样做：

	NSArray* myArray = @[@"one", @"two", @"three"];
	
	for(NSString* string in myArray){
	  // this code repeated 3 times, one for each item in the array
	}

编译器会自动产生低开销的代码遍历容器每一个项。


	


	



	



