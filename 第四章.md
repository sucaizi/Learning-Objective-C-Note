# <center>第四章 OS X 和 iOS 应用

对用户而言，应用不过是跟系统里的文件一样的东西。毕竟，电脑是为用户设计，而安装的程序又定义了电脑能够做什么。

作为一个开发者，很容易陷入构建app的细节－类，方法和结构。不过用户只关心你应用的卖点。

在本章，你将了解到OS X 和iOS 应用如何构造，应用能够做些什么，不能做些什么。

###  什么是应用

iOS 和OS X 应用的打包方式和其他平台的很不同，尤其Windows平台。在其他平台，工程编译后是一个包含编译代码的二进制文件，之后由开发者将二进制文件和资源文件打包。在Linux，你需要打包文件，在Window，通常要创建一个安装程序。

OS X 和iOS 则采用另一种方法。即使用所谓‘包’的概念－对用户而言是一个单独文件。
很多文档格式化是用包作为存储和组织数据的有效途径，因为将数据块不做不同的文件存储意味程序无需实现解压单独文件的逻辑。

所以应用实际是包含编译好的二进制文件和它需要的资源文件。OS X 和iOS 应用的结构稍有不同，不过如何打包程序的原理是一样的。你可以在Finder中右击应用去展示其内部包含的内容。

当你用XCode 编译和创建应用时，XCode 会创建一个包，并复制任何需要的资源到里面。如果你创建的是一个MAC 应用，你可以压缩它并发送到任何人去运行它。在iOS上就有点不同，因为应用必须有代码签名并且放到应用商店后才能在设备运行。

这样做的好处之一，就是应用可以在Mac任意变更目录。

### 应用，框架，工具和其他

XCode 不但可以创建应用，还可以创建框架。框架和应用的结构差不多，同样有二进制文件和资源文件，但不是独立的且设计给其他应用使用。

Mac上一个典型的例子就是 AppKit 框架，在iOS上等同的是UIKit 框架。

### 应用由什么组成？

组建以一个iOS 或 OS X应用至少包括两样：

*  已编译的二进制文件
*  描述app 系统信息的文件

已编译的二进制文件是由XCode编译并链接。
而描述信息会保存在Info.plist文件，其包含：

*  应用图标名
*  应用可以打开何种类型文件
*  已编译的二进制文件名
*  应用启动时加载的接口文件名
*  语言支持
*  应用是否支持多任务（用于iOS）
*  应用归属Mac 应用商店何种分类（用于OS X）

这个文件非常重要，如果你移除了它，应用就无法启动。

应用同时也包含应编译进来的资源文件－－图片，文件，音频和其他通过XCode工程添加进来的项目。应用可以在运行时引用这些资源。

你可以通过一下步骤了解OS X应用的结构：

1.  打开XCode，创建一个新的OS X 应用，一切默认后，保存。
2.  编译。
3.  在导航栏，你可以看到编译后产生的.app 文件，右击文件，选择在Finder 中打开，就会展示app包含什么了。
4. 右击应用，选择 ‘显示包内容’，Finder 就会显示其内容。

在iOS上，所有东西都包含在包文件的根目录，而OS X更为严格点。

比如一个名为MyApp 的Mac应用的结构如下：

MyApp.app 包的最上层

	Contents 一个包含应用的文件夹
	Info.plist 应用的系统信息描述
	MacOS 一个包含已经编译的二进制文件的文件夹
	PkgInfo 描述应用作者和这是个什么应用的文件。
	Resources 一个包含已编译的资源文件的文件夹

而在iOS 的结构则如下：

	MyApp 已编译的二进制文件
	Info.plist 描述应用的系统信息的文件
	Default.png 应用启动时默认展示的图片
	Default@2x.png Default.png 的高分辨率版本
	embedded。mobileprovision 描述标识应用可在设备上运行的文件
	Entitlements.plist 描述应用可以做什么和不可以做什么的文件


因为你的应用可能安装在系统的任何地方，所以你的代码不可以用绝对路径寻找资源文件，幸运的是，Cocoa 已经考虑到这一点并指导你如何做。

### 使用NSBundle 查找应用的资源

随着编码的进行，你的应用需要考虑在不同平台上运行，这时就用到NSBundle 这个类。通过NSBundle 可以获得应用所在的磁盘位置，以及获取已编译的资源。

对于iOS应用，这显得尤其重要，因为应用可能安装到任意的位置，你的代码不能依赖某以路径，更不能写死路径。一旦这么做了，在iOS保证会出问题。

你可以使用NSBundle 检测应用所在的位置，不过一般只需要知道某单独资源所在的位置，你所要做的，就是给出资源的名字和类型。

比如，下面的代码就是返回SomeImage.png 的相对路径：

	NSString* resourcePath = [[NSBundle mainBundle] pathForResource: @"SomeImage" ofType: @"png"];
	// resourcePath is now a string containing the
	// absolute path reference to SomeImage.png
	
注意 [NSBundle mainBundle] 这个调用－可能由多个bundle(记住，应用所有的资源都可以作为bundle)

你还可以得到资源的URL：

	NSURL* resourceURL = [[NSBundle mainBundle] URLForResource: @"SomeImage" ofType: @"png"];
	
方法会在资源文件夹查找文件（在iOS，则从应用的根目录开始查找）

对磁盘的文件而言，使用绝对路径和URL 是一样的，但推荐使用URL。文件的URL 一般是这样的：file:///Applications/Xcode.app/。

如果你向工程添加了图像或其他资源，这会把资源都复制到工程编译所在的路径。对与Mac应用而言，资源文件会复制到Resources文件夹，而iOS，则是应用的根目录。

### 应用的生命周期
每个程序都有启动，运行和终止的状态。比较有意思的是这些状态切换时做了什么。大多数情况，OS X和iOS 的行为是一样的，除了iOS处理多任务时和标准桌面应用不一样外。

在本节，我们将分别讨论这两种应用的生命周期，以及生命周期的状态切换时所发生的事情。

####OS X 应用
当程序启动时，系统首要做的是打开Info.plist。系统根据这个文件查找到已编译的二进制文件的位置并加载。此时，你编写的代码接管系统。

除了编译的代码以外，还有为运行时准备和捆绑的对象集合。这些对象也叫接口对象--准备好窗口，控件和场景－程序编译时存储在nib文件。当应用运行时，这些nib文件就会打开，预先创建的对象就会加载到内存。

应用首先打开nib文件并反序列化其内容。即应用加载窗口，控件和取出存储在nib里面的任何东西并链接它们。主nib文件包含了应用的委托对象。

从nib文件加载完对象后，就发送awakeFromNib 消息。此时，对象就可以开始运行代码了。

总而言之，从nib文件加载的对象接收的时awakeFromNib消息。而自己代码创建的对象则接收init 方法。

此时，应用准备开始运行。接着要做的是向应用委托对象发送applicationDidFinishLaunching:方法，完了，应用就正式进入 run loop 状态。所谓的run loop 是个无限循环，由Cocoa管理，直到程序退出为止。run loop 的目的是监听事件－键盘输入、鼠标移动和点击，计时器暂停等-同时发送这些事件到相关的目标。比如，你有一个事件挂在一个按钮上，当点击按钮时就触发事件。若用户点击了按钮，鼠标点击的事件就发送到按钮，然后就会执行目标事件的代码。

在OS X，应用会继续运行即使用户正在运行其他应用。用户在切换其他应用时，应用的委托对象就会收到applicationWillResignActive: 消息，表明应用准备进入非活动状态，接着，会再接收到applicationDidResignActive: 消息。

以上两个方法之所以要分离开来，是为了让你的代码在iOS系统按下home键，或在OS X切换应用时更好地管理屏幕上所发生的事。当调用applicationWillResignActive:，应用仍然显示在屏幕，当应用不再可见时，应用就会接收到applicationDidResignActive:消息。

如果用户再次切换到原应用，应用就会接收到一对相对应的方法：applicationWillBecomeActive： 和 applicationDidBecomeActive:。这些方法会在应用再次被激活之前和之后立即发送。

应用退出时，事件循环就终止。这时，应用会接收到applicationWillTerminate: 消息，这也是应用保存文件最后的时机。

#### iOS 应用

iOS 应用的大部分行为和OS X 应用是相同的，仅小部分不同。iOS 设备有限的内存决定了其实现多任务时需要严格使用内存。

iOS 同一时间只能有一个应用在屏幕上－其他应用则是隐藏的。可见的应用称为前台应用，而隐藏的则称为后台应用。一个应用在后台运行多长时间时有严格限制的，后续会介绍。

当使用iOS应用时，用户可能被其他事情打断－比如电话来电，这时用户正在交互的应用就会被切换。从技术角度来看，应用依然在前台运行，只是非活动状态。如果用户接听电话，电话应用变成了运行在前端，而之前使用的程序就切换到后台运行。

还有其他途径使得应用变成非活动状态，比如用户下拉通知中心，打开任务切换器，或者执行其他操作。当应用进入了非活动状态，可能时它退出的信号，所以最好做一些保存的工作。

iOS应用生命周期和OS X的也几乎一致。当应用加载时，检查Info.plist 文件，查找可运行文件并加载，于是应用开始执行代码，取出资源文件等。

应用加载完毕后，接着接收到applicationDidFinishLaunching: withOptions: 方法。这也和OS X的类似，不过会有一个额外的参数－dictionary，包含了应用为何和怎样加载的信息。

通常，用户触摸应用图标就可以启动应用，也可以由其他应用启动，比如一个应用传递文件到另一个应用。可选参数dictionary 包含了描述应用在什么情况下启动应用。

和OS X一样，iOS应用也会接收到applicationWillResignActive: 和applicationDidBecomeActive: 消息（有一点不同，消息里的参数时NSNotification 兑对象，而iOS 则是UIApplicaton）。

当用户终止运行OS X 应用时，我们直到，应用会接收到applicationWillTerminate: 消息。iOS4 之前也是这么做的，之后，引入了多任务，iOS应用的生命周期就被改变了。

##### iOS 多任务







